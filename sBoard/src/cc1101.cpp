/*
 * cc1101.cpp
 *
 *  Created on: Jan 19, 2016
 *      Author: Greg Perrin
 */

#include "../inc/cc1101.h"
#include <stdio.h>

/*
 * CC1101 Constructor
 *
 * See cc1101.h for spi_bus init
 *
 * args: none
 */
CC1101::CC1101()
{
}

/*
 * CC1101 Destructor
 *
 * args: none
 */
CC1101::~CC1101()
{
}

/*
 * CC1101 Destructor
 *
 * args: none
 */
void CC1101::setup()
{
	__delay_cycles(1000);
	this->write_config();
	GDO2_PxIES |= GDO2_PIN;          // Int on falling edge (end of pkt)
	GDO2_PxREN |= GDO2_PIN;		     //enable pullup/pulldown resistor
	GDO2_PxOUT |= GDO2_PIN;		     //now pull resistor up
	GDO2_PxIFG &= ~(GDO2_PIN);       // Clear flag
	GDO2_PxIE  |= GDO2_PIN;          // Enable int on end of packet
	P1DIR &= ~(BIT2 + BIT5);         // Just in case...
	P1IN &= ~(BIT2 + BIT5);
	//P1REN |= (BIT2);                 // Enable internal pull-up/down resistors
	//P1OUT &= ~(BIT2);                // Select pull-down mode for P1.35
	__bis_SR_register(GIE);
}

/*
 * CC1101 chip configuration
 *
 * Settings/values generated by SmartRF Studio
 *
 * args: none
 */
void CC1101::write_config()
{
	char PA[] =  {0x8E};
	const unsigned char PA_LEN = 1;
	this->spi_bus.write_register(IOCFG0  ,0x06);      // Debug TX 0x06 :: Debug RX 0x00
	this->spi_bus.write_register(IOCFG2  ,0x06);      //Debug RX 0x00
	this->spi_bus.write_register(FIFOTHR ,0x47);      // 0x47 TX -- see table for threshold values
	this->spi_bus.write_register(PKTCTRL0,0x05);
	this->spi_bus.write_register(FSCTRL1 ,0x06);
	this->spi_bus.write_register(FREQ2   ,0x23);
	this->spi_bus.write_register(FREQ1   ,0x31);
	this->spi_bus.write_register(FREQ0   ,0x3B);
	this->spi_bus.write_register(MDMCFG4 ,0xF5);
	this->spi_bus.write_register(MDMCFG3 ,0x83);
	this->spi_bus.write_register(MDMCFG2 ,0x1B);          // Manchester encoding disabled
	this->spi_bus.write_register(MDMCFG1 ,0x22);
	this->spi_bus.write_register(DEVIATN ,0x31);
	this->spi_bus.write_register(MCSM0   ,0x18);
	this->spi_bus.write_register(FOCCFG  ,0x16);
	this->spi_bus.write_register(WORCTRL ,0xFB);
	this->spi_bus.write_register(FSCAL3  ,0xE9);
	this->spi_bus.write_register(FSCAL2  ,0x2A);
	this->spi_bus.write_register(FSCAL1  ,0x00);
	this->spi_bus.write_register(FSCAL0  ,0x1F);
	this->spi_bus.write_register(TEST2   ,0x81);
	this->spi_bus.write_register(TEST1   ,0x35);
	this->spi_bus.write_register(TEST0   ,0x09);
	this->spi_bus.write_burst_register(PATABLE, PA, PA_LEN);
}

/*
 * CC1101 configuration check
 *
 * Reads out a written CC1101 register value to ensure SPI write was successful.
 *
 * args: none
 */
bool CC1101::check_config()
{
	char err_val = this->spi_bus.read_register(FREQ0);
	__delay_cycles(5000);
	if ((int)err_val == 59) {      // FREQ0 in (ascii decimal)
		//this->set_idle();          // Set IDLE and wait.
		return true;
	} else {
		return false;
	}

}

/*
 * CC1101 set to recieve
 *
 * args: none
 */
void CC1101::set_receive(void)
{
	this->spi_bus.strobe(SRX);	    //put into RX mode
}

/*
 * CC1101 set to idle
 *
 * args: none
 */
void CC1101::set_idle(void)
{
	this->spi_bus.strobe(SIDLE);    //put int IDLE mode
}

/*
 * CC1101 configuration check
 *
 * Reads out register value to ensure SPI write was successful
 *
 * args: none
 */
void CC1101::set_sleep(void)
{
	this->spi_bus.strobe(SXOFF);	//turn off
}

/*
 * CC1101 configuration check
 *
 * Flush TX buffer for next character set.
 *
 * args: none
 */
void CC1101::flush_tx(void)
{
	this->spi_bus.strobe(SFTX);	    //turn off
}

/*
 * CC1101 configuration check
 *
 * Flush TX buffer for next character set.
 *
 * args: none
 */
void CC1101::flush_rx(void)
{
	this->spi_bus.strobe(SFRX);	    //turn off
}

/*
 * CC1101 packet TX
 *
 * Transfer packet in TX FIFO.
 *
 * args: tx_buffer: Char array of TX HEX characters.
 *       size: Size of TX buffer.
 */
void CC1101::send_packet(char *tx_buffer, char size)
{
	this->spi_bus.write_burst_register(TXFIFO, tx_buffer, size);   // Write TX data
	this->spi_bus.strobe(STX);           				           // Change state to TX, initiating data transfer
	while (!(P1IN & BIT5));                                        // Wait GDO0 (BIT5) to go hi -> sync TX'ed
	while ((P1IN & BIT5));                                         // Wait GDO0 to clear -> end of pkt
	GDO0_PxIFG &= ~(GDO0_PIN);      			                   // After pkt TX, this flag is set, has to be cleared
	this->spi_bus.strobe(SIDLE);
}

/*
 * CC1101 packet RX
 *
 * Transfer packet in TX FIFO.
 *
 * args: tx_buffer: Char array of TX HEX characters.
 *       size: Size of TX buffer.
 */
char CC1101::receive_packet(char *rx_buffer, char *length)
{
  char preamble[2];
  char status[2];
  char packet_len = 0;
  char return_flag = 0;
  packet_len = this->spi_bus.read_register(RXFIFO);
  this->spi_bus.read_burst_register(RXFIFO, preamble, 2);
  this->spi_bus.read_burst_register(RXFIFO, rx_buffer, packet_len - 2);
  this->spi_bus.read_burst_register(RXFIFO, status, 2);
  /*
  if ((this->spi_bus.read_status(RXBYTES) & NUM_RXBYTES)) {
	  packet_len = this->spi_bus.read_register(RXFIFO); 			               // Read length byte
	  if (true) {
	  //if (packet_len <= *length) {
		  //while ((P1IN & BIT2));                                                 // Wait for Pin 2 to go high                                                        // Wait for Pin 2 to go high
		  this->spi_bus.read_burst_register(RXFIFO, rx_buffer, 32);              // Pull data
		  *length = packet_len;                                                    // Return the actual size
		  //this->spi_bus.read_burst_register(RXFIFO, status, 2);
		  // Read appended status bytes
		  //return_flag = (char)(status[LQI_RX] & CRC_OK);
		  //__delay_cycles(1000);
		  //while (!(P1IN & BIT2));
		  //this->spi_bus.strobe(SFRX);
		  //return_flag = 1;
	  } else {                                                                    // Return CRC_OK bit
		  *length = packet_len;                                                   // Return read size
		  //this->spi_bus.strobe(SFRX);      				                          // Flush RXFIFO
	  }
  }
  */
  return return_flag;							                                  // 1 = good, 0 = bad
}

/*
 * CC1101 poll receive flag
 *
 * Check flag to see if RX is coming
 *
 * args: none
 */
char CC1101::poll_receive_flag(void)
{
	char return_flag = 0;
	if (GDO0_PIN & GDO0_PxIN) {
		while (GDO0_PIN & GDO0_PxIN) {}
		return_flag = 1;
	}
	return return_flag;
}

/*
 * Get the RSSI from the CC1101 and return it.
 *
 * The RSSI value read from the RSSI status register is a 2’s complement number and is in
 * dBm with ½ dB resolution.
 *
 * args: none
 *
 */
short CC1101::get_rssi(void)
{
	unsigned char rssi_dec;			//base ten reading
	short rssi_dBm;			        //dbm value
	const char rssi_offset = 74;
	const unsigned char NEGATIVE = 128;

	//get RSSI
	rssi_dec = this->spi_bus.read_status(RSSI);
	//if negative, convert to dBm
	if (rssi_dec >= NEGATIVE) {
		rssi_dBm = (( rssi_dec - 256) / 2) - rssi_offset;
	} else {
		rssi_dBm = (rssi_dec / 2) - rssi_offset;
	}
	return rssi_dBm;
}

/*
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
	#pragma vector=PORT1_VECTOR
	__interrupt void PORT_1(void)
#elif defined(__GNUC__)
	void __attribute__ ((interrupt(PORT1_VECTOR))) PORT1ISR (void)
#else
	#error Compiler not supported!
#endif
{

	if (GDO2_PxIFG & GDO2_PIN) {
		GDO2_PxIFG &= ~(GDO2_PIN);
	}
	//LPM3_EXIT;

}
*/
